<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A compiler for the C0 language targeting `x86_64` and LLVM IR, featuring SSA, register allocation via chordal graph coloring, and optimizations competitive with `gcc -O1`.">
  <title>C0 Compiler - Raaid Tanveer</title>
  <link rel="canonical" href="https://raaidtanveer.com/projects/c0-compiler">
  <link rel="icon" type="image/svg+xml" href="../favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script>
</head>
<body>
  <header class="header">
    <div class="container header-inner">
      <a href="../index.html" class="logo">Raaid Tanveer</a>
      <nav class="nav">
        <a href="../index.html" class="nav-link">Home</a>
        <a href="../about.html" class="nav-link">About</a>
        <a href="../blog.html" class="nav-link">Blog</a>
        <a href="../projects.html" class="nav-link active">Projects</a>
      </nav>
    </div>
  </header>

  <main>
    <div class="container">
      <article class="blog-post prose">
        <h1>C0 Compiler</h1>
        

        <div class="blog-post-content">
          <p>A fully-featured compiler for the <a href="https://c0.cs.cmu.edu/docs/c0-reference.pdf">C0 language</a>, a safe subset of C used for teaching at CMU. The compiler targets both <code>x86_64</code> directly and LLVM IR (enabling compilation to ARM and other architectures). With all optimizations enabled, the compiler achieves an average <strong>1.74x speedup</strong> on benchmark test cases.</p>
<h2>Pipeline Overview</h2>
<p>The compiler supports two backends: a native x86-64 backend and an LLVM IR backend for cross-platform compilation.</p>
<pre class="mermaid">
flowchart LR
    subgraph FE[Frontend]
        A[C0 Source] --> B[Lexer]
        B --> C[Parser]
        C --> D[Elaborator]
        D --> E[Type Checker]
    end

    subgraph ME[Middle-end]
        F[IR Translation] --> G{Target?}
        G -->|x86-64| H[IR Opts]
        H --> I[Abstract Assembly]
        G -->|LLVM| J[LLVM IR]
    end

    subgraph BE[x86 Backend]
        K[Asm Opts] --> L[Reg Alloc]
        L --> M[x86-64]
    end

    subgraph LLVM[LLVM Backend]
        N[llc] --> O[x86_64 / ARM / etc.]
    end

    FE --> ME
    I --> BE
    J --> LLVM
</pre>

<h2>Implementation</h2>
<h3>Frontend</h3>
<ul>
<li><strong>Lexer</strong> with lexer hack for distinguishing type identifiers from regular identifiers</li>
<li><strong>Parser</strong> built using Menhir</li>
<li><strong>Elaboration</strong> pass for semantic analysis and AST transformation</li>
</ul>
<h3>Middle-end</h3>
<ul>
<li><strong>IR translation</strong> to a lower-level intermediate representation</li>
<li><strong>SSA construction</strong> for enabling dataflow optimizations</li>
</ul>
<h2>Optimizations</h2>
<p>The compiler implements optimizations at two layers: the intermediate representation (IR) and abstract assembly.</p>
<pre class="mermaid">
flowchart LR
    subgraph IR[IR Optimizations]
        A[Function Inlining] --> B[Tail Call Opt]
        B --> C[Reachability]
    end

    subgraph SSA[SSA Optimizations]
        D[CCP] --> E[ADCE]
        E --> F[Copy Prop]
        F -.->|repeat| D
    end

    subgraph Loop[Loop Optimizations]
        G[Loop-nest Tree] --> H[Invariant Hoisting]
        H --> I[Alignment]
    end

    subgraph x86[x86 Peephole]
        J[Redundant Moves]
        K[Unnecessary LEA]
        L[Unnecessary JMP]
    end

    IR --> SSA --> Loop --> x86
</pre>

<h3>IR Optimizations</h3>
<h4>Tail Call Optimization</h4>
<p>For functions that end in recursive tail calls (not mutual recursion), we remove the tail call and instead move the arguments into the correct argument temps, then jump to a point at the beginning of the function body. This eliminates function calling stack overhead and makes control-flow analysis easier. This optimization was critical for preventing stack overflows in deeply recursive programs.</p>
<h4>Function Inlining</h4>
<p>We perform function inlining for non-recursive calls up to a call depth of 3, only inlining functions with at most 100 lines in the body. For example, if function <code>f</code> calls <code>g</code>, <code>g</code> calls <code>h</code>, and <code>h</code> calls <code>i</code>, we inline <code>g</code> into <code>f</code>, <code>h</code> into <code>g</code>, and <code>i</code> into <code>h</code>, but we don&#39;t inline beyond that depth.</p>
<p>Inlining was particularly effective when combined with constant propagation, as it allows constants to propagate across function boundaries. This effectively removed many small arithmetic helper functions entirely.</p>
<h4>Reachability Analysis</h4>
<p>We transform the IR into basic blocks and prune any blocks that are unreachable from the function entry point.</p>
<h3>Abstract Assembly Optimizations</h3>
<h4>Strength Reductions</h4>
<p>Standard strength reduction pass replacing expensive operations (like multiplication by powers of two) with cheaper equivalents (like left shifts).</p>
<h4>Conditional Constant Propagation (CCP)</h4>
<p>Adapted from the Appel textbook, this algorithm performs constant propagation while simultaneously pruning branches that would not be taken based on constant values. Combined with function inlining, CCP can propagate constants across function boundaries, enabling significant simplifications.</p>
<h4>Aggressive Dead Code Elimination (ADCE)</h4>
<p>Adapted from the Cooper textbook, this removes branches and instructions within the control flow graph that are not necessary for effectful operations such as returns, memory accesses, or function calls.</p>
<h4>Loop Invariant Hoisting</h4>
<p>Using a Loop-nest tree construction, we identify instructions within loops that can be hoisted to loop preheaders. The algorithm works recursively from the deepest nested loops outward, using hoisted invariants from inner loops when computing invariants for parent loops.</p>
<h4>Register Coalescing</h4>
<p>Using a union-find data structure, we coalesce moves between temps that are not live at the same time. This is a fast single-pass optimization that runs at all optimization levels.</p>
<h3>x86 Optimizations</h3>
<p>We eliminate self-move operations (moves of the form <code>%rax &lt;- %rax</code>). This optimization became especially valuable after register coalescing, since coalesced temps are assigned the same register, making their original move instructions redundant.</p>
<h3>Backend</h3>
<ul>
<li>Instruction selection for <code>x86_64</code></li>
<li>Register allocation via chordal graph coloring</li>
<li>Peephole optimizations (redundant moves, unnecessary <code>lea</code> and <code>jmp</code> removal)</li>
</ul>
<h2>LLVM Backend</h2>
<p>The compiler also supports emitting LLVM IR, which can then be compiled via <code>llc</code> to target multiple architectures including ARM.</p>
<h3>Safety Checks</h3>
<p>To match C0&#39;s dynamic semantics in safe mode, we inject control flow checks for:</p>
<ul>
<li>Division/modulus by zero</li>
<li>Division of <code>INT_MIN</code> by <code>-1</code></li>
<li>Shift amounts outside the range <code>[0, 32)</code></li>
</ul>
<p>These checks raise <code>SIGFPE</code> when an illegal operation is attempted.</p>
<h3>SSA Adaptations</h3>
<p>LLVM IR requires phi nodes to contain values for every incoming edge to a basic block. We adapted our SSA representation by adding dummy values (0 for integers, null for pointers) on edges where a temp has not yet been defined.</p>
<h3>Performance</h3>
<p>When targeting ARM via LLVM on Apple Silicon, native ARM code showed significant speedups over x86-64 code running through Rosetta translation.</p>

        </div>
      </article>
    </div>
  </main>

  <footer class="footer">
    <div class="container footer-inner">
      <div class="footer-content">
        <p class="copyright">&copy; <span id="year"></span> Raaid Tanveer</p>
        <nav class="social-links">
          <a href="https://github.com/raaidrt" target="_blank" rel="noopener noreferrer" class="social-link">GitHub</a>
          <a href="https://www.linkedin.com/in/raaidrt/" target="_blank" rel="noopener noreferrer" class="social-link">LinkedIn</a>
          <a href="https://twitter.com/raaidrt" target="_blank" rel="noopener noreferrer" class="social-link">Twitter</a>
        </nav>
      </div>
    </div>
  </footer>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>
</body>
</html>